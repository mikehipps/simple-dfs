<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CSV Match (Round 4)</title>
<style>
  :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
  body { margin: 24px; background: var(--bg); color: var(--text); transition: background 0.2s ease, color 0.2s ease; }
  body.theme-light {
    color-scheme: light;
    --bg: #f5f7fa;
    --text: #111;
    --surface: #ffffff;
    --surface-alt: #f0f2f6;
    --border: #d0d5dd;
    --muted: #5f6b7a;
    --chip-bg: #e8ecf5;
    --chip-text: #0b7285;
    --ok: #0a7;
    --warn: #b50;
    --bad: #c00;
    --code-bg: #f1f3f8;
    --table-header: #e8ecf5;
    --input-bg: #ffffff;
  }
  body.theme-dark {
    color-scheme: dark;
    --bg: #0f172a;
    --text: #e2e8f0;
    --surface: #1e293b;
    --surface-alt: #24324d;
    --border: #334155;
    --muted: #94a3b8;
    --chip-bg: #1e3a8a;
    --chip-text: #e0f2fe;
    --ok: #34d399;
    --warn: #fbbf24;
    --bad: #f87171;
    --code-bg: #1f2937;
    --table-header: #1e293b;
    --input-bg: #0f172a;
  }
  h1 { margin: 0 0 12px; }
  fieldset { border: 1px solid var(--border); border-radius: 10px; padding: 12px; margin: 12px 0; background: var(--surface); }
  legend { padding: 0 6px; }
  label { display: inline-block; margin: 6px 12px 6px 0; }
  select, input[type="text"], button { padding: 6px 8px; margin: 4px 8px; background: var(--input-bg); color: var(--text); border: 1px solid var(--border); border-radius: 6px; }
  button { cursor: pointer; background: var(--chip-bg); color: var(--chip-text); border: none; font-weight: 600; }
  .theme-toggle { margin-left: 0; }
  .row { display: flex; gap: 16px; align-items: center; flex-wrap: wrap; }
  .col { flex: 1 1 320px; }
  .muted { color: var(--muted); }
  .chip { display: inline-block; padding: 2px 6px; background: var(--chip-bg); border-radius: 6px; margin-right: 6px; color: var(--chip-text); }
  .ok { color: var(--ok); font-weight: 600; }
  .warn { color: var(--warn); font-weight: 600; }
  .bad { color: var(--bad); font-weight: 600; }
  .box { border: 1px dashed var(--border); border-radius: 8px; padding: 10px; background: var(--surface-alt); }
  .grid { display: grid; grid-template-columns: repeat(2, minmax(260px,1fr)); gap: 12px; }
  .small { font-size: 12px; }
  .code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: var(--code-bg); padding: 2px 4px; border-radius: 4px; }
  table { border-collapse: collapse; width: 100%; }
  th, td { border-bottom: 1px solid var(--border); padding: 6px 8px; text-align: left; }
  th { background: var(--table-header); position: sticky; top: 0; }
  .review-table { max-height: 300px; overflow: auto; border: 1px solid var(--border); border-radius: 8px; background: var(--surface); }
  .row-inline { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
</style>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.min.js"></script>
</head>
<body class="theme-dark">
<div class="row" style="justify-content: space-between; align-items: center; margin-bottom: 12px;">
  <h1 style="margin: 0;">CSV Match (Round 4)</h1>
  <button id="themeToggle" class="theme-toggle" type="button">Switch theme</button>
</div>
<p class="muted">Upload two CSVs, choose a <b>Primary</b>, map <b>Name</b>/<b>Team</b> (Name can be composed like first+last), review unresolved rows, then export. All in-browser.</p>
<div class="row">
  <label><b>Sport</b>
    <select id="sportSelect">
      <option value="nfl" selected>NFL</option>
      <option value="mlb">MLB</option>
      <option value="nba">NBA</option>
      <option value="nhl">NHL</option>
    </select>
  </label>
</div>

<fieldset>
  <legend>1) Upload files</legend>
  <div class="row">
    <div class="col">
      <label><b>File A</b> <input type="file" id="fileA" accept=".csv" /></label>
      <div id="metaA" class="small muted"></div>
    </div>
    <div class="col">
      <label><b>File B</b> <input type="file" id="fileB" accept=".csv" /></label>
      <div id="metaB" class="small muted"></div>
    </div>
  </div>
  <div class="row">
    <label><input type="radio" name="primary" value="A" checked> Primary = File A</label>
    <label><input type="radio" name="primary" value="B"> Primary = File B</label>
  </div>
</fieldset>

<fieldset>
  <legend>2) Choose match keys</legend>
  <div class="grid">
    <div>
      <div><b>File A</b></div>
      <div class="row-inline">
        <label>Name mode:
          <select id="nameModeA">
            <option value="single">Single column</option>
            <option value="compose">Compose from columns</option>
          </select>
        </label>
        <label id="nameASingleWrap">Name: <select id="nameA"></select></label>
      </div>
      <div id="nameAComposeWrap" class="row-inline" style="display:none;">
        <label>Compose:
          <select id="nameACompose" multiple size="5" style="min-width:220px;"></select>
        </label>
        <label>Separator: <input type="text" id="nameASeparator" value=" " size="2"/></label>
      </div>
      <label>Team: <select id="teamA"></select></label>
    </div>
    <div>
      <div><b>File B</b></div>
      <div class="row-inline">
        <label>Name mode:
          <select id="nameModeB">
            <option value="single">Single column</option>
            <option value="compose">Compose from columns</option>
          </select>
        </label>
        <label id="nameBSingleWrap">Name: <select id="nameB"></select></label>
      </div>
      <div id="nameBComposeWrap" class="row-inline" style="display:none;">
        <label>Compose:
          <select id="nameBCompose" multiple size="5" style="min-width:220px;"></select>
        </label>
        <label>Separator: <input type="text" id="nameBSeparator" value=" " size="2"/></label>
      </div>
      <label>Team: <select id="teamB"></select></label>
    </div>
  </div>
  <div class="small muted">Matching is restricted to the same canonical team (prevents cross-team collisions). DST names auto-normalized (e.g., "Baltimore D/ST" → "Baltimore Ravens").</div>
</fieldset>

<fieldset>
  <legend>3) Columns to keep</legend>
  <div class="row">
    <div class="col">
      <div><b>Keep from File A</b></div>
      <div id="keepA" class="box small"></div>
      <label>Prefix for A-kept columns: <input id="prefA" type="text" value="A_" /></label>
    </div>
    <div class="col">
      <div><b>Keep from File B</b></div>
      <div id="keepB" class="box small"></div>
      <label>Prefix for B-kept columns: <input id="prefB" type="text" value="B_" /></label>
    </div>
  </div>
</fieldset>

<fieldset>
  <legend>4) Merge</legend>
  <div class="row">
    <button id="btnMerge">Run match</button>
    <span id="status" class="muted"></span>
  </div>
  <div id="summary" class="small"></div>

  <div id="reviewSection" style="display:none; margin-top:10px;">
    <h3>Review unresolved rows</h3>
    <p class="small muted">Pick a candidate within the same team, or choose "No match". Tick "Save alias" to remember your choice.</p>
    <div class="review-table">
      <table>
        <thead>
          <tr>
            <th>#</th>
            <th>Primary Name</th>
            <th>Team</th>
            <th>Candidates (same team)</th>
            <th>Save alias</th>
          </tr>
        </thead>
        <tbody id="reviewBody"></tbody>
      </table>
    </div>
    <div class="row">
      <button id="btnApplyReview">Apply review & update</button>
    </div>
  </div>

  <div class="row" style="margin-top:10px;">
    <button id="btnExportCSV" disabled>Download merged.csv</button>
    <button id="btnExportManifest" disabled>Download manifest.json</button>
  </div>
</fieldset>

<script>
// ---------- helpers ----------
const FALLBACK_SUFFIXES = ["jr","sr","ii","iii","iv","v"];
const FALLBACK_NICK = {
  "mike":"michael","tony":"anthony","aj":"a j","a.j.":"a j","jd":"j d","j.d.":"j d",
  "rob":"robert","bob":"robert","rick":"richard","dave":"david","chris":"christopher",
  "drew":"andrew","andy":"andrew","bill":"william","billy":"william","will":"william",
  "alex":"alexander","sasha":"alexander"
};

const FALLBACK_NFL_CODE_BY_KEY = {
  "ari":"ARI","arizona":"ARI","arizona cardinals":"ARI","cardinals":"ARI",
  "atl":"ATL","atlanta":"ATL","atlanta falcons":"ATL","falcons":"ATL",
  "bal":"BAL","baltimore":"BAL","baltimore ravens":"BAL","ravens":"BAL",
  "buf":"BUF","buffalo":"BUF","buffalo bills":"BUF","bills":"BUF","buffallo":"BUF",
  "car":"CAR","carolina":"CAR","carolina panthers":"CAR","panthers":"CAR",
  "chi":"CHI","chicago":"CHI","chicago bears":"CHI","bears":"CHI",
  "cin":"CIN","cincinnati":"CIN","cincinnati bengals":"CIN","bengals":"CIN",
  "cle":"CLE","cleveland":"CLE","cleveland browns":"CLE","browns":"CLE",
  "dal":"DAL","dallas":"DAL","dallas cowboys":"DAL","cowboys":"DAL",
  "den":"DEN","denver":"DEN","denver broncos":"DEN","broncos":"DEN",
  "det":"DET","detroit":"DET","detroit lions":"DET","lions":"DET",
  "gb":"GB","gnb":"GB","green bay":"GB","green bay packers":"GB","packers":"GB",
  "hou":"HOU","houston":"HOU","houston texans":"HOU","texans":"HOU",
  "ind":"IND","indianapolis":"IND","indianapolis colts":"IND","colts":"IND",
  "jax":"JAX","jac":"JAX","jacksonville":"JAX","jacksonville jaguars":"JAX","jaguars":"JAX",
  "kc":"KC","kan":"KC","kansas city":"KC","kansas city chiefs":"KC","chiefs":"KC",
  "lv":"LV","las vegas":"LV","oak":"LV","rai":"LV","las vegas raiders":"LV","raiders":"LV",
  "lac":"LAC","sd":"LAC","los angeles chargers":"LAC","chargers":"LAC",
  "lar":"LAR","los angeles rams":"LAR","rams":"LAR",
  "mia":"MIA","miami":"MIA","miami dolphins":"MIA","dolphins":"MIA",
  "min":"MIN","minnesota":"MIN","minnesota vikings":"MIN","vikings":"MIN",
  "ne":"NE","nwe":"NE","new england":"NE","new england patriots":"NE","patriots":"NE",
  "no":"NO","nor":"NO","new orleans":"NO","new orleans saints":"NO","saints":"NO",
  "nyg":"NYG","new york giants":"NYG","giants":"NYG",
  "nyj":"NYJ","new york jets":"NYJ","jets":"NYJ",
  "phi":"PHI","philadelphia":"PHI","philadelphia eagles":"PHI","eagles":"PHI",
  "pit":"PIT","pittsburgh":"PIT","pittsburgh steelers":"PIT","steelers":"PIT",
  "sf":"SF","sfo":"SF","san francisco":"SF","san francisco 49ers":"SF","49ers":"SF","niners":"SF",
  "sea":"SEA","seattle":"SEA","seattle seahawks":"SEA","seahawks":"SEA",
  "tb":"TB","tampa":"TB","tampa bay":"TB","tampa bay buccaneers":"TB","bucs":"TB","buccaneers":"TB",
  "ten":"TEN","tens":"TEN","tennessee":"TEN","tennessee titans":"TEN","titans":"TEN",
  "was":"WAS","wsh":"WAS","washington":"WAS","washington commanders":"WAS","commanders":"WAS","football team":"WAS","redskins":"WAS"
};
const FALLBACK_NFL_FULL_BY_CODE = {
  "ARI":"Arizona Cardinals","ATL":"Atlanta Falcons","BAL":"Baltimore Ravens","BUF":"Buffalo Bills",
  "CAR":"Carolina Panthers","CHI":"Chicago Bears","CIN":"Cincinnati Bengals","CLE":"Cleveland Browns",
  "DAL":"Dallas Cowboys","DEN":"Denver Broncos","DET":"Detroit Lions","GB":"Green Bay Packers",
  "HOU":"Houston Texans","IND":"Indianapolis Colts","JAX":"Jacksonville Jaguars","KC":"Kansas City Chiefs",
  "LV":"Las Vegas Raiders","LAC":"Los Angeles Chargers","LAR":"Los Angeles Rams","MIA":"Miami Dolphins",
  "MIN":"Minnesota Vikings","NE":"New England Patriots","NO":"New Orleans Saints","NYG":"New York Giants",
  "NYJ":"New York Jets","PHI":"Philadelphia Eagles","PIT":"Pittsburgh Steelers","SF":"San Francisco 49ers",
  "SEA":"Seattle Seahawks","TB":"Tampa Bay Buccaneers","TEN":"Tennessee Titans","WAS":"Washington Commanders"
};
const FALLBACK_DST_PATTERNS = ["d/st","dst","defense","def"];

let SUFFIXES;
let NICK;
let NFL_CODE_BY_KEY;
let NFL_FULL_BY_CODE;
let DST_PATTERNS;
let DST_REGEX = /(?!)/i;
let sportLoadToken = 0;

function isPlainObject(value) {
  return !!value && typeof value === "object" && !Array.isArray(value);
}
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function dstPatternToRegexSource(pattern) {
  const escaped = escapeRegex(pattern);
  const withSlash = escaped.replace(/\\\//g, "\\s*\\/\\s*");
  return withSlash.replace(/\s+/g, "\\s*");
}
function buildDSTRegex(patterns) {
  const sources = (Array.isArray(patterns) ? patterns : [])
    .map(p => (p ?? "").toString().trim().toLowerCase())
    .filter(Boolean)
    .map(dstPatternToRegexSource);
  if (!sources.length) {
    return /(?!)/i;
  }
  return new RegExp("(?:" + sources.join("|") + ")\\b", "i");
}
function sanitizeStringList(list) {
  return (Array.isArray(list) ? list : [])
    .map(item => (item ?? "").toString().trim().toLowerCase())
    .filter(Boolean);
}
function buildSuffixSet(list) {
  return new Set(sanitizeStringList(list));
}
function applyTeamOverrides(map) {
  if (!isPlainObject(map)) return;
  Object.entries(map).forEach(([key, value]) => {
    if (typeof value !== "string") return;
    NFL_CODE_BY_KEY[key.toLowerCase()] = value.toUpperCase();
  });
}
function applyTeamFullOverrides(map) {
  if (!isPlainObject(map)) return;
  Object.entries(map).forEach(([key, value]) => {
    if (typeof value !== "string") return;
    NFL_FULL_BY_CODE[key.toUpperCase()] = value;
  });
}
function applyNicknameOverrides(source) {
  if (!isPlainObject(source)) return;
  Object.entries(source).forEach(([key, value]) => {
    if (typeof value !== "string") return;
    const k = key.toLowerCase();
    const v = value.toLowerCase();
    if (k && v) NICK[k] = v;
  });
}
function initializeDataFromFallback() {
  NFL_CODE_BY_KEY = {};
  applyTeamOverrides(FALLBACK_NFL_CODE_BY_KEY);
  NFL_FULL_BY_CODE = {};
  applyTeamFullOverrides(FALLBACK_NFL_FULL_BY_CODE);
  NICK = {};
  applyNicknameOverrides(FALLBACK_NICK);
  SUFFIXES = buildSuffixSet(FALLBACK_SUFFIXES);
  DST_PATTERNS = sanitizeStringList(FALLBACK_DST_PATTERNS);
  DST_REGEX = buildDSTRegex(DST_PATTERNS);
}
async function fetchJSON(path) {
  try {
    const res = await fetch(path, { cache: "no-store" });
    if (!res.ok) return null;
    return await res.json();
  } catch {
    return null;
  }
}
async function loadDataSeeds(sport) {
  const requestId = ++sportLoadToken;
  try {
    const [teamData, nickData, suffixData, dstData] = await Promise.all([
      fetchJSON(`data/${sport}_teams.json`),
      fetchJSON("data/nicknames_common.json"),
      fetchJSON("data/suffixes.json"),
      fetchJSON("data/dst_patterns.json")
    ]);
    if (requestId !== sportLoadToken) return;

    initializeDataFromFallback();

    if (teamData && isPlainObject(teamData.map)) {
      applyTeamOverrides(teamData.map);
    }
    if (teamData && isPlainObject(teamData.fullByCode)) {
      applyTeamFullOverrides(teamData.fullByCode);
    }
    if (isPlainObject(nickData)) {
      applyNicknameOverrides(nickData);
    }
    if (Array.isArray(suffixData) && suffixData.length) {
      SUFFIXES = buildSuffixSet(suffixData);
    }
    if (Array.isArray(dstData) && dstData.length) {
      DST_PATTERNS = sanitizeStringList(dstData);
      DST_REGEX = buildDSTRegex(DST_PATTERNS);
    }
  } catch (err) {
    if (requestId !== sportLoadToken) return;
    console.warn("Failed to load data seeds", err);
    initializeDataFromFallback();
  }
}

initializeDataFromFallback();

function normText(x) {
  if (x == null) return "";
  return (x+"")
    .normalize("NFKD").replace(/[^\u0000-\u007E]/g, "")
    .replace(/[^a-zA-Z0-9\s]/g, " ").toLowerCase().replace(/\s+/g, " ").trim();
}
function normName(name) {
  const t = normText(name);
  const parts = t.split(" ").filter(Boolean).map(w => NICK[w] || w).join(" ").split(" ");
  const cleaned = parts.filter(w => !SUFFIXES.has(w));
  return cleaned.join(" ");
}
function canonTeam(t) {
  const k = normText(t);
  return NFL_CODE_BY_KEY[k] || k.toUpperCase();
}
function isDSTName(n, teamCode) {
  // Check for explicit D/ST patterns
  if (DST_REGEX.test(n || "")) return true;
  
  // Check if name is just a team name (common for defense teams)
  if (teamCode) {
    const normalized = normText(n);
    const teamFullName = normText(teamFullNameFromCode(teamCode));
    const teamShortNames = Object.keys(NFL_CODE_BY_KEY).filter(key =>
      NFL_CODE_BY_KEY[key] === teamCode && key !== teamFullName
    );
    
    // If the normalized name matches any team short name, treat as D/ST
    return teamShortNames.some(shortName => shortName === normalized);
  }
  
  return false;
}
function teamFullNameFromCode(code) { return NFL_FULL_BY_CODE[code] || code; }
function dstNormalizedName(name, teamCode) {
  if (!teamCode) return normName(name);
  return normText(teamFullNameFromCode(teamCode)).split(" ").join(" ");
}
function download(filename, text) {
  const blob = new Blob([text], {type: "text/plain;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename; a.click();
  setTimeout(() => URL.revokeObjectURL(url), 1000);
}
function getAliases() { try { return JSON.parse(localStorage.getItem("csvMatchAliases") || "{}"); } catch { return {}; } }
function setAliases(obj) { localStorage.setItem("csvMatchAliases", JSON.stringify(obj)); }

// ---------- state ----------
let A = null, B = null;
let headersA = [], headersB = [];
let mergedStore = null, manifest = null;
let reviewItems = [];

// ---------- UI refs ----------
const themeToggle = document.getElementById("themeToggle");
const sportSelect = document.getElementById("sportSelect");
const fileA = document.getElementById("fileA");
const fileB = document.getElementById("fileB");
const metaA = document.getElementById("metaA");
const metaB = document.getElementById("metaB");
const nameModeA = document.getElementById("nameModeA");
const nameModeB = document.getElementById("nameModeB");
const nameASingleWrap = document.getElementById("nameASingleWrap");
const nameAComposeWrap = document.getElementById("nameAComposeWrap");
const nameBSingleWrap = document.getElementById("nameBSingleWrap");
const nameBComposeWrap = document.getElementById("nameBComposeWrap");
const nameA = document.getElementById("nameA");
const teamA = document.getElementById("teamA");
const nameB = document.getElementById("nameB");
const teamB = document.getElementById("teamB");
const nameACompose = document.getElementById("nameACompose");
const nameBCompose = document.getElementById("nameBCompose");
const nameASeparator = document.getElementById("nameASeparator");
const nameBSeparator = document.getElementById("nameBSeparator");
const keepA = document.getElementById("keepA");
const keepB = document.getElementById("keepB");
const prefA = document.getElementById("prefA");
const prefB = document.getElementById("prefB");
const btnMerge = document.getElementById("btnMerge");
const btnExportCSV = document.getElementById("btnExportCSV");
const btnExportManifest = document.getElementById("btnExportManifest");
const status = document.getElementById("status");
const summary = document.getElementById("summary");
const reviewSection = document.getElementById("reviewSection");
const reviewBody = document.getElementById("reviewBody");
const btnApplyReview = document.getElementById("btnApplyReview");

function applyTheme(theme) {
  const next = theme === "theme-light" ? "theme-light" : "theme-dark";
  document.body.classList.remove("theme-light", "theme-dark");
  document.body.classList.add(next);
  if (themeToggle) {
    themeToggle.textContent = next === "theme-dark" ? "Switch to Light Mode" : "Switch to Dark Mode";
  }
  localStorage.setItem("csvMatchTheme", next);
}

const preferredTheme = localStorage.getItem("csvMatchTheme") || (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "theme-dark" : "theme-light");
applyTheme(preferredTheme);

if (themeToggle) {
  themeToggle.addEventListener("click", () => {
    const next = document.body.classList.contains("theme-dark") ? "theme-light" : "theme-dark";
    applyTheme(next);
  });
}

function fillSelect(sel, headers) {
  sel.innerHTML = "";
  const opt = (v) => { const o=document.createElement("option"); o.value=v; o.textContent=v; return o; };
  sel.appendChild(opt("— choose —"));
  headers.forEach(h => sel.appendChild(opt(h)));
}
function fillMultiSelect(sel, headers) {
  sel.innerHTML = "";
  headers.forEach(h => {
    const o=document.createElement("option"); o.value=h; o.textContent=h; sel.appendChild(o);
  });
}
function fillKeep(box, headers) {
  box.innerHTML = "";
  headers.forEach(h => {
    const lbl = document.createElement("label");
    lbl.style.display = "inline-block";
    lbl.style.marginRight = "10px";
    lbl.innerHTML = `<input type="checkbox" data-col="${h}" checked> <span class="code">${h}</span>`;
    box.appendChild(lbl);
  });
}
function parseCSV(file, cb) {
  Papa.parse(file, { header: true, skipEmptyLines: true, complete: r => cb(null, r), error: e => cb(e, null) });
}

function toggleNameMode(which) {
  if (which === "A") {
    const mode = nameModeA.value;
    nameASingleWrap.style.display = mode === "single" ? "inline-block" : "none";
    nameAComposeWrap.style.display = mode === "compose" ? "flex" : "none";
  } else {
    const mode = nameModeB.value;
    nameBSingleWrap.style.display = mode === "single" ? "inline-block" : "none";
    nameBComposeWrap.style.display = mode === "compose" ? "flex" : "none";
  }
}
nameModeA.addEventListener("change", () => toggleNameMode("A"));
nameModeB.addEventListener("change", () => toggleNameMode("B"));

fileA.addEventListener("change", e => {
  const f = e.target.files[0]; if (!f) return;
  parseCSV(f, (err, res) => {
    if (err) { metaA.textContent = "Error parsing A: " + err; return; }
    A = res.data; headersA = res.meta.fields || [];
    metaA.textContent = `${f.name} — ${A.length} rows, ${headersA.length} columns`;
    fillSelect(nameA, headersA); fillSelect(teamA, headersA);
    fillMultiSelect(nameACompose, headersA);
    fillKeep(keepA, headersA);
  });
});
fileB.addEventListener("change", e => {
  const f = e.target.files[0]; if (!f) return;
  parseCSV(f, (err, res) => {
    if (err) { metaB.textContent = "Error parsing B: " + err; return; }
    B = res.data; headersB = res.meta.fields || [];
    metaB.textContent = `${f.name} — ${B.length} rows, ${headersB.length} columns`;
    fillSelect(nameB, headersB); fillSelect(teamB, headersB);
    fillMultiSelect(nameBCompose, headersB);
    fillKeep(keepB, headersB);
  });
});

function buildNameGetter(mode, singleSel, composeSel, sep) {
  if (mode === "compose") {
    return (row) => {
      const cols = [...composeSel.selectedOptions].map(o => o.value);
      const pieces = cols.map(c => (row[c] ?? "").toString().trim()).filter(Boolean);
      return pieces.join(sep || " ");
    };
  } else {
    return (row) => (row[singleSel.value] ?? "").toString();
  }
}

function buildIndex(rows, getName, teamCol) {
  const aliases = getAliases();
  const items = rows.map(r => {
    const teamCode = canonTeam(r[teamCol]);
    let nameRaw = getName(r);
    let n = normName(nameRaw);
    if (isDSTName(nameRaw, teamCode)) n = dstNormalizedName(nameRaw, teamCode);
    const aliasKey = teamCode + "::" + n;
    const aliased = aliases[aliasKey];
    const finalName = aliased || n;
    return { row:r, _norm_name:finalName, _norm_team:teamCode };
  });
  const map = new Map();
  for (const it of items) {
    const key = it._norm_name + "||" + it._norm_team;
    if (!map.has(key)) map.set(key, []);
    map.get(key).push(it);
  }
  const byTeam = new Map();
  for (const it of items) {
    if (!byTeam.has(it._norm_team)) byTeam.set(it._norm_team, []);
    byTeam.get(it._norm_team).push(it);
  }
  const fuseByTeam = new Map();
  for (const [t, arr] of byTeam.entries()) {
    fuseByTeam.set(t, new Fuse(arr, { keys: ["_norm_name"], threshold: 0.12, includeScore: true }));
  }
  return { items, map, fuseByTeam };
}

function gatherKeep(box) {
  return [...box.querySelectorAll('input[type="checkbox"]:checked')].map(i => i.dataset.col);
}

document.getElementById("btnMerge").addEventListener("click", () => {
  if (!A || !B) { status.textContent = "Upload both files first."; return; }
  const primary = [...document.querySelectorAll('input[name="primary"]')].find(r => r.checked)?.value || "A";

  const getNameA = buildNameGetter(nameModeA.value, nameA, nameACompose, nameASeparator.value);
  const getNameB = buildNameGetter(nameModeB.value, nameB, nameBCompose, nameBSeparator.value);

  const P = primary === "A" ? A : B;
  const S = primary === "A" ? B : A;
  const nameGetterP = primary === "A" ? getNameA : getNameB;
  const nameGetterS = primary === "A" ? getNameB : getNameA;
  const teamP = primary === "A" ? teamA.value : teamB.value;
  const teamS = primary === "A" ? teamB.value : teamA.value;

  if (!teamP || !teamS || teamP.startsWith("—") || teamS.startsWith("—")) {
    status.textContent = "Pick Team columns for both files."; return;
  }

  const keepColsA = gatherKeep(keepA);
  const keepColsB = gatherKeep(keepB);
  const prefixA = prefA.value || "A_";
  const prefixB = prefB.value || "B_";

  status.textContent = "Matching...";
  const Sidx = buildIndex(S, nameGetterS, teamS);

  let auto=0, review=0, missing=0;
  let merged = [];
  reviewItems = [];

  for (let i=0;i<P.length;i++) {
    const pr = P[i];
    const teamCode = canonTeam(pr[teamP]);
    let rawName = nameGetterP(pr);
    let norm = normName(rawName);
    if (isDSTName(rawName, teamCode)) norm = dstNormalizedName(rawName, teamCode);

    const aliases = getAliases();
    const aliasKey = teamCode + "::" + norm;
    const aliasedNorm = aliases[aliasKey] || norm;

    let match = null, reason = "";
    const hard = Sidx.map.get(aliasedNorm + "||" + teamCode) || [];
    if (hard.length === 1) { match = hard[0].row; reason = "exact"; auto++; }
    else if (hard.length > 1) { match = hard[0].row; reason = "exact_multi"; auto++; }
    else {
      const fuse = Sidx.fuseByTeam.get(teamCode);
      if (fuse) {
        let res = fuse.search(aliasedNorm).slice(0,3); // strict
        if (!(res.length && res[0].score <= 0.12)) {
          res = fuse.search(aliasedNorm).slice(0,3);   // still show top 3
        }
        if (res.length) {
          reason = "review"; review++;
          const cands = res.map(x => ({ name: x.item._norm_name, row: x.item.row }));
          reviewItems.push({ idx:i, projRow: pr, teamCode, candidates: cands, choice: cands[0]?.name || "", saveAlias: true, rawName });
        } else {
          reason = "missing"; missing++;
          reviewItems.push({ idx:i, projRow: pr, teamCode, candidates: [], choice: "", saveAlias: false, rawName });
        }
      } else {
        reason = "missing"; missing++;
        reviewItems.push({ idx:i, projRow: pr, teamCode, candidates: [], choice: "", saveAlias: false, rawName });
      }
    }

    const out = {};
    if (primary==="A") { keepColsA.forEach(c => out[(prefixA + c)] = pr[c]); }
    else { keepColsB.forEach(c => out[(prefixB + c)] = pr[c]); }
    if (match) {
      if (primary==="A") { keepColsB.forEach(c => out[(prefixB + c)] = match[c]); }
      else { keepColsA.forEach(c => out[(prefixA + c)] = match[c]); }
    }
    out["_match_reason"] = match ? reason : (reason || "missing");
    merged.push(out);
  }

  mergedStore = merged;
  manifest = { counts:{ auto, review, missing }, primary };
  status.textContent = "Done.";
  summary.innerHTML = `
    <span class="chip ok">auto: ${auto}</span>
    <span class="chip warn">review: ${review}</span>
    <span class="chip bad">missing: ${missing}</span>
    <span class="muted">(${mergedStore.length} rows)</span>
  `;
  renderReviewTable();
});

function renderReviewTable() {
  reviewBody.innerHTML = "";
  if (!reviewItems.length) { reviewSection.style.display = "none"; btnExportCSV.disabled = false; btnExportManifest.disabled = false; return; }
  reviewSection.style.display = "block";
  reviewItems.slice(0, 500).forEach((it, idx) => {
    const tr = document.createElement("tr");
    const sel = document.createElement("select");
    sel.innerHTML = "";
    const optNone = document.createElement("option"); optNone.value=""; optNone.textContent="— No match —"; sel.appendChild(optNone);
    it.candidates.forEach(c => {
      const o = document.createElement("option"); o.value = c.name; o.textContent = c.name; sel.appendChild(o);
    });
    sel.value = it.choice || "";
    sel.addEventListener("change", () => it.choice = sel.value);
    const chk = document.createElement("input"); chk.type="checkbox"; chk.checked = !!it.saveAlias;
    chk.addEventListener("change", () => it.saveAlias = chk.checked);

    const td0 = document.createElement("td"); td0.textContent = (idx+1);
    const td1 = document.createElement("td"); td1.textContent = it.rawName || "";
    const td2 = document.createElement("td"); td2.textContent = it.teamCode;
    const td3 = document.createElement("td"); td3.appendChild(sel);
    const td4 = document.createElement("td"); td4.appendChild(chk);
    tr.appendChild(td0); tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3); tr.appendChild(td4);
    reviewBody.appendChild(tr);
  });

  btnApplyReview.onclick = () => {
    const aliases = getAliases();
    for (const it of reviewItems) {
      if (it.choice && it.saveAlias) {
        let norm = normName(it.rawName);
        if (isDSTName(it.rawName, it.teamCode)) norm = dstNormalizedName(it.rawName, it.teamCode);
        aliases[it.teamCode + "::" + norm] = it.choice;
      }
    }
    setAliases(aliases);
    btnExportCSV.disabled = false;
    btnExportManifest.disabled = false;
    alert("Review applied. You can now export.");
  };
}

document.getElementById("btnExportCSV").addEventListener("click", () => {
  if (!mergedStore) return;
  const csv = Papa.unparse(mergedStore);
  download("merged.csv", csv);
});
document.getElementById("btnExportManifest").addEventListener("click", () => {
  if (!manifest) return;
  download("manifest.json", JSON.stringify(manifest, null, 2));
});

sportSelect.addEventListener("change", () => {
  loadDataSeeds(sportSelect.value);
});
loadDataSeeds(sportSelect.value);
</script>
</body>
</html>
